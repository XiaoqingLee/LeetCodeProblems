redis zset 的 score 字段是可以使用固定有限精度浮点数的。

在 redis c 实现中使用了 double 数据类型。
在 本次 python 实现中我使用了 float 数据类型。

浮点数在硬件中实际储存的值只是最接近目标值的计算机可表示的二进制分数。

浮点数的比较: 当比较操作符" == "的两个操作数底层的二进制表示完全相同的时候该操作符返回真。

这意味着:
    (1) 如果两个操作符在底层是同一个实例。
    (2) 如果一个操作符是另一个操作符 bit-to-bit 拷贝而来， 两个实例自拷贝发生后再无in-place运算发生。
        注意 bit-to-bit 拷贝，源对象和目的对象必须是相同精度长度的，如double->double可以，double->float就不可以了。
    (3) 如果两个操作数是不同的十进制数，但共享相同的最接近的近似二进制小数。
        例如， 0.1 、 0.10000000000000001 、 0.1000000000000000055511151231257827021181583404541015625
        全都近似于 3602879701896397 / 2 ** 55。
这三种情况返回真。

redis c 实现中的 score 符合 (2)
本次 python 实现中的 score 符合 (1)


另外：

https://docs.python.org/zh-cn/3/library/stdtypes.html#typesnumeric
Python 完全支持混合运算：
当一个二元算术运算符的操作数有不同数值类型时，"较窄"类型的操作数会拓宽到另一个操作数的类型，
其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。


    Python 3.10.4 (tags/v3.10.4:9d38120, Mar 23 2022, 23:13:41)
    >>>
    >>> a = 0.10000000000000001
    >>> b = 0.1000000000000000055511151231257827021181583404541015625
    >>> id(a) == id(b)
    False
    >>> a == b
    True
    >>> a.as_integer_ratio()
    (3602879701896397, 36028797018963968)
    >>> b.as_integer_ratio()
    (3602879701896397, 36028797018963968)
    >>>
    >>> a = 42
    >>> b = 42
    >>> id(a) == id(b)
    True
    >>> a == b
    True
    >>>
    >>> a = 42
    >>> b = 42.0
    >>> id(a) == id(b)
    False
    >>> a == b
    True
    >>> a.as_integer_ratio()
    (42, 1)
    >>> b.as_integer_ratio()
    (42, 1)
    >>>
